#!/usr/bin/env python
# ~/.pythonrc

import math
import os
from pprint import pprint, pformat
import re
import subprocess
import sys
import time
from types import ModuleType

from tabulate import tabulate

from lancore import *


IGNORED_ATTRIBUTES = ["__builtins__", "__globals__", "func_globals"]
MAX_LINES = 50
PYTHON_HISTORY_PATH = os.path.join(os.environ['HOME'], '.python_history')
TYPE_TO_REGEX = {
    'E-mail': r'^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,5})$',
    'Whole number': r'^\d+$',
    'Negative int': r'^-\d+$',
    'Negative float': r'^-\d+$',
    'Decimal number (float)': r'^\d*\.\d+$',
    'IP Address': r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',
    'MAC Address': r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$',
    'UUID': r'[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}',
}
FILE_TYPE_TO_EXTENSION = {
    'EXR image': 'exr',
    'Katana file': 'katana',
    'Log file': 'log',
    'Markdown file': 'md',
    'Maya ascii file': 'ma',
    'Maya binary file': 'mb',
    'Nuke script': 'nk',
    'JSON file': 'json',
    'Python file': 'py',
}


def _var_name(var, locals=locals()):
    '''Hacky way of getting variable name from variable. Empty string if not found.

    >>> foo = 5
    >>> _var_name(foo)
    'foo'
    '''
    for name, val in locals.iteritems():
        if val == var:
            return name
    return ''


def _brighten_it_up(func):
    """Brighten up the output"""
    def wrapper(*args, **kwargs):
        sys.stdout.write(BRIGHT)
        res = func(*args, **kwargs)
        sys.stdout.write(RESET_ALL)
        return res
    return wrapper


def human_int(int_):
    '''Add commas to int every 3 digits (ie. 1,234,567,890)'''
    return '{:,}'.format(int_)


def _num_lines(str_):
    '''Number of lines in string'''
    return str_.count('\n') + 1


def wai(*things, **kwargs):
    for thing in things:
        _wai(thing, **kwargs)


def _wai_text(str_, typ):
    '''What is this text? Can be unicode or str.'''
    if str_:
        if os.path.exists(str_):
            # It's a file path.
            if os.path.isfile(str_):
                for file_type, extension in FILE_TYPE_TO_EXTENSION.iteritems():
                    if str_.endswith(extension):
                        print file_type
                        break
                else:
                    print 'file path'
            else:
                print 'directory'
        else:
            # Match by regex of what we know.
            for type_, regex in TYPE_TO_REGEX.iteritems():
                if re.match(regex, str_):
                    print type_
                    break
            else:
                print 'Just a %s:' % typ.__name__, str_
    else:
        print "Empty %s: ''" % typ.__name__


def _wai_number(num, typ):
    '''What is this number? Can be int or float.'''
    if num >= 946702800:  # Epoch date
        print "Epoch time"
        print time.strftime("%Z - %a %Y-%m-%d, %I:%M:%S %p", time.localtime(num))
    elif typ == int:
        if num >= 16:
            # Check if it's a power of 2
            log = math.log(num, 2)
            if log.is_integer():
                print "%i = 2^%i" % (num, int(log))
                return
        print "Just an int:", human_int(num)
    elif typ == float:
        print "Just a float:", num


def _wai_list(list_, typ):
    '''What is this list/tuple?'''
    if list_:
        print BLUE + "%s of %s %s%s" % (
            typ.__name__.title(),
            human_int(len(list_)),
            get_types(list_),
            "s" if len(list_) > 1 else ""
        )
        print NORMAL + GREEN + "%s[0]: " % _var_name(list_),
        pprint(list_[0]), BRIGHT
        _print_parent_types(type(list_[0]))
    else:
        print DIM + "Empty %s: %s" % (typ.__name__, str(list_)) + RESET_ALL


def _wai_dict(dict_):
    '''What is this dict?'''
    if dict_:
        keys = dict_.keys()
        print BLUE + 'Just a dict of %i {%s: %s}' % (
            len(dict_), get_types(keys), get_types(dict_.values()))

        keys_print = pformat(sorted(keys)).split('\n')
        print 'Keys: ' + colorama.Style.RESET_ALL + GREEN + '\n'.join(keys_print[:50])
        if len(keys_print) > MAX_LINES:
            print '...'

        # Print dict with least number of depth that's less than MAX_LINES.
        depth = 1
        previous_output = ''
        while True:
            output = pformat(dict_, depth=depth)
            if output.count('\n') > MAX_LINES:
                break

            # Check if everything expanded.
            if output == previous_output:
                break
            previous_output = output
            depth += 1
        if previous_output and depth > 2:
            print BRIGHT_BLUE('Dict:') + GREEN
            print previous_output
    else:
        print DIM + 'Empty dict: {}' + RESET_ALL


@_brighten_it_up
def _wai(thing, ignore_private=False, ignore_attrs=[], call=False, skip_callable=False,
         skip_module=True, skip_known=False):
    """What Am I? Prints type and attributes of object thing.

    :param thing object: Anything and everything. That's what we're here to find out. :)
    :param ignore_private bool: Ignores attributes starting with underscore.
    :param ignore_attrs list: Attributes to ignore.
    :param call bool: Calls attributes that are functions and thing itself if it is callable.
    :param skip_callable bool: Doesn't print callable attributes.
    :param skip_module bool: Skips module attributes.
    :param skip_known bool: If True, prints every attribute even if we know what it is.
    """
    typ = type(thing)

    if not skip_known:
        # Let's see if we know what it is first.
        if thing is None:
            print "It's just None!"
            return
        elif typ in (str, unicode):
            return _wai_text(thing, typ)
        elif typ in (int, float):
            return _wai_number(thing, typ)
        elif typ == dict:
            return _wai_dict(thing)

        from collections import defaultdict, Counter
        if typ in (defaultdict, Counter):
            print BLUE + "%s with %i key%s: %s" % (
                typ.__name__.title(), len(thing), 's' if len(thing) > 1 else '', thing.keys())
            return
        elif typ in (list, tuple):
            return _wai_list(thing, typ)

    if callable(thing):
        print _func_name_args_kwargs(thing)
        if thing.__doc__:
            print thing.__doc__

    # So we don't know what it is. Let's print everything we can find about it.
    thing_name = getattr(thing, "__name__", "")
    call_count = private_count = total = 0
    ignore_attrs += IGNORED_ATTRIBUTES
    for attr in dir(thing):
        if attr in ignore_attrs:
            continue
        if attr.startswith("_"):
            private_count += 1
            if ignore_private:
                continue
        total += 1
        try:
            res = getattr(thing, attr)
        except Exception, e:
            print RED + str(e)
            continue

        # Skip if module
        if isinstance(res, ModuleType) and skip_module:
            continue

        # Skip if callable
        is_callable = callable(res)
        long_name = "%s.%s" % (thing_name, attr)
        if is_callable and skip_callable:
            continue
        elif is_callable:
            # Print *args, **kwargs
            print _func_name_args_kwargs(res),
            call_count += 1
            if call:
                _call(res)
            else:
                print getattr(res, "__doc__")
        else:
            print BLUE + "%s:" % long_name + GREEN,
            _print(res)
    if call and callable(thing):
        _call(thing)
    sys.stdout.write(CYAN)
    if not skip_callable:
        print "Callable: %i," % call_count,
    print "Uncallable: %i" % (total - call_count)
    print "Private: %i, Public: %i" % (private_count, total - private_count)
    print "Total: %i" % total

    _print_parent_types(typ)


def _func_name_args_kwargs(func):
    varnames_str = ""
    code = getattr(func, "__code__", None)
    if code:
        co_argcount = getattr(code, "co_argcount", None)
        co_varnames = getattr(code, "co_varnames", None)
        if co_argcount and co_varnames:
            try:
                varnames = list(co_varnames)[0:co_argcount]
            except TypeError:
                print "Could not get func args for", co_varnames
                return varnames_str
            defaults = getattr(func, "__defaults__", [])
            if defaults:
                for i, default in enumerate(defaults):
                    index = len(varnames) - len(defaults) + i
                    varnames[index] = MAGENTA + varnames[index] + BLUE + "=" + YELLOW + \
                        str(default) + BLUE
            varnames_str = ", ".join(varnames)
    func_name = func.__name__ if hasattr(func, '__name__') else str(func)
    return BLUE + "%s(%s):" % (func_name, varnames_str) + GREEN


def _print_parent_types(typ):
    """Print types of all parent classes"""
    import inspect
    print typ
    print CYAN + "Parents:" + GREEN, " -> ".join([t.__name__ for t in inspect.getmro(typ)[1:]])
    print CYAN + "Type:" + GREEN, typ.__name__, RESET


def get_types(items):
    '''String of unique types in items.

    >>> get_types(['a', 'b', 'c'])
    'str'
    >>> get_types(['apple', 'banana', u'peach', 2])
    'int, unicode, str'
    '''
    found_types = set()
    for item in items:
        found_types.add(type(item))
    return ', '.join([typ.__name__ for typ in found_types])


def _call(func):
    try:
        res = func()
        _print(res)
    except Exception, e:
        print RED, e


def _print(to_print):
    if isinstance(to_print, basestring):
        print to_print
    else:
        pprint(to_print)


def ns(msg=""):
    """Sends a desktop notification using alias ns"""
    subprocess.call("ns '%s'" % msg, shell=True)


def cb(content):
    """Copies content to clipboard"""
    import clipboard, pyperclip
    try:
        clipboard.copy(content)
    except pyperclip.PyperclipException:
        clipboard.copy(str(content))


def start_qt_application():
    from PyQt4 import QtGui
    return QtGui.QApplication(sys.argv)


def my_date_time_stamp():
    '''Date time stamp the way I like it.'''
    return datetime.datetime.now().strftime('%c')


def _history(include_current=False):
    """Returns current interactive python session command history"""
    msg = []
    history_len = readline.get_current_history_length()
    end = (history_len + 1) if include_current else history_len
    for i in range(1, end):
        msg.append(readline.get_history_item(i))
    return "\n".join(msg)


current_history = _history


def history(n=50, c=False):
    """Python version of bash history command

    Args:
        n (int): Lines to print
        c (bool): Clears history if True
    """
    if c:
        open(PYTHON_HISTORY_PATH, "w").close()
        return

    if not os.path.exists(PYTHON_HISTORY_PATH):
        return
    try:
        os.system("tail -%i %s" % (n, PYTHON_HISTORY_PATH))
    except IOError:
        pass
    print BRIGHT_BLUE("\nCurrent session [%s]:" % my_date_time_stamp())
    print _history()


def _append_history_file():
    history = _history(include_current=True)
    if not history:
        return
    with open(PYTHON_HISTORY_PATH, "a+") as fil:
        fil.write(
            BRIGHT_BLUE("\n'''New session [%s]'''\n" % my_date_time_stamp()))
        fil.write(history + "\n")


# Make h print history without having to call function. h() works too.
class History:
    def __call__(self):
        history()

    def __repr__(self):
        history()
        return ''

h = History()

less_history = lambda : os.system('less -r +G %s' % PYTHON_HISTORY_PATH)


def hs(str_, max_count=5):
    '''Search interactive python history using grep. Returns last max_count results.

    Args:
        str_ (str): String to search for.
        max_count (int): Max number of lines to show.
    '''
    os.system('grep "%s" %s | tail -%i | grep --color=auto "%s"' % (
        str_, PYTHON_HISTORY_PATH, max_count, str_))


def _is_text(s):
    return type(s) in [str, unicode]


def find(haystack, needle, all=False, first=False, ignore_case=True, max_results=50):
    '''Recursively finds path to needle in haystack (can be list or dict).

    Args:
        haystack (dict or list): A dict or list.
        needle (anything): Target to find.
        all (bool): Shows all results if True. Up to max_results otherwise.
        first (bool): Returns first result if True. All results otherwise.
        ignore_case (bool): Case-insensitive if True.
        max_results (int): Max number of results to return. Unlimited if negative or zero.

    Returns:
        (list of paths to needle): Results as list of keys to needle.
    '''
    INFO('Searching...')
    all_ = all
    results = _find(haystack, needle, first, ignore_case)
    if not results:
        INFO('Not found')
        return
    for index, result in enumerate(results):
        if not all_ and index >= max_results > 0:
            # Max number of results reached.
            print 'Displayed first %i results...' % max_results
            break

        # Print path to value and value itself.
        path = ''
        for attr in result:
            if _is_text(attr):
                path += "['%s']" % attr
            else:
                path += '[%s]' % attr
        print '%s%s:' % (_var_name(haystack), path),
        print eval('haystack%s' % path)
    num_results = len(results)
    if not first:
        INFO('Found %s result%s' % (human_int(num_results), 's' if num_results > 1 else ''))


def _find(haystack, needle, first, ignore_case):
    '''Recursive helper for find().'''
    results = []
    if isinstance(haystack, dict):
        iterable = sorted(haystack.iteritems())
    elif isinstance(haystack, list):
        iterable = enumerate(haystack)
    else:
        # Not sure how to iterate or if iterable.
        return results

    for key, val in iterable:
        if isinstance(val, (dict, list)):
            res = _find(val, needle, first, ignore_case)
            if res:
                results.append([key] + res[0])
                if first:
                    break
        elif val == needle:
            results.append([key])
            if first:
                break
        elif val:
            if _is_text(val) and _is_text(needle):
                if ignore_case:
                    if needle.lower() in val.lower():
                        # Is text and in val, case-insensitive.
                        results.append([key])
                        if first:
                            break
                else:
                    if needle in val:
                        # Is text and in val, case-sensitive.
                        results.append([key])
                        if first:
                            break

    return results


def demo_colorama(case='upper'):
    '''Print every style and color possible with colorama.

    Args:
        case (str): One of 'upper', 'title', or 'lower'.
    '''
    for color in dir(colorama.Fore):
        if color.isupper() and color != 'RESET':
            print getattr(colorama.Fore, color),
            for style in dir(colorama.Style):
                if style.isupper() and style != 'RESET_ALL':
                    text = '"%s %s"' % (style, color)
                    if case == 'title':
                        text = text.title()
                    elif case == 'lower':
                        text = text.lower()
                    print getattr(colorama.Style, style), text,
            print
    sys.stdout.write(RESET_ALL)


def reload_pythonrc():
    '''Reload this file to update current CLI session without exiting. Reloadception!'''
    execfile(os.environ.get('PYTHONSTARTUP'))


'''
Aliases for easier access. How lazy am I?
'''
def print_tabulate(dicts):
    print tabulate(dicts, headers='keys')


# Enable syntax completion and append history file on exit
try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import atexit
    import rlcompleter
    readline.parse_and_bind("tab: complete")
    atexit.register(_append_history_file)
    del atexit, rlcompleter


# My custom Python prompt.
class MyPrompt:
    def __repr__(self):
        now = datetime.datetime.now()
        return '%s >>> ' % str(now.strftime('%I:%M:%S %p'))

sys.ps1 = MyPrompt()
