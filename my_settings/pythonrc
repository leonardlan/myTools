#!/usr/bin/env python
# ~/.pythonrc

'''Useful functions, variables, and setup configs to use in Python CLI.'''

import os
import re
import sys
import time

# Enable syntax completion.
import atexit
import rlcompleter

start = time.time()

from pprint import pprint

# My Tools.

import python_compatibility

from cli_tools import (cb, cb_strings, confirm, diff, find, get, print_env_vars,
    print_my_python_modules, print_python_path, print_sys_path, Timer)
from colors import *
from file_tools import read_file, write_file
from json_tools import dump_json, load_json
from lancore import *
from list_tools import print_duplicates
from my_settings import HOME
from notify_tools import ns
from os_tools import tree
from path_tools import open_path, print_path
from python_compatibility import reload, exec_file
from smart_list import SmartList
from subprocess_tools import meld, subl
from wai import wai, call_gets

# For playing around in CLI.
# from mock_data import DOGS, DOGS_DICT, PEOPLE, PEOPLE_DICT, TYPE_TO_VAL


_SESSION_START_DATETIME = datetime.datetime.now()


PYTHON_HISTORY_PATH = os.path.join(HOME, '.python_history')


IS_LINUX = sys.platform.startswith('linux')


def start_qt_application():
    from PyQt5 import QtWidgets
    return QtWidgets.QApplication(sys.argv)


# Only Linux specific.
if IS_LINUX:
    less_history = lambda: os.system('less -r +G %s' % PYTHON_HISTORY_PATH)


    def hs(str_, max_count=5):
        '''Regex search interactive python history using grep. Returns last max_count results.

        Args:
            str_ (str): String to search for.
            max_count (int): Max number of lines to show.
        '''
        os.system('grep "%s" %s | tail -%i | grep --color=auto "%s"' % (
            str_, PYTHON_HISTORY_PATH, max_count, str_))


def reload_pythonrc():
    '''Reload this file to update current CLI session without exiting. Reloadception!'''
    if python_compatibility.is_in_python_2():
        exec_file(os.environ.get('PYTHONSTARTUP'))
    else:
        warning("Reloading pythonrc in Python 3+ isn't working yet.")


def pwd():
    '''Print current working directory.'''
    print(os.getcwd())


# Add print_tabulate() if tabulate module available.
try:
    import tabulate
except ImportError:
    warning('Module tabulate not available.')
else:
    from tabulate_tools import print_tabulate


# Add tab complete and append history file on exit.
try:
    import readline
except ImportError:
    warning('Module readline not available. No tab complete available.')
else:
    # Enable tab complete.
    readline.parse_and_bind('tab: complete')


    def _history(include_current=False):
        '''Returns current interactive python session command history.'''
        msg = []
        history_len = readline.get_current_history_length()
        end = (history_len + 1) if include_current else history_len
        for i in range(1, end):
            msg.append(readline.get_history_item(i))
        return '\n'.join(msg)


    def history(n=50, c=False):
        '''Python version of bash history command

        Args:
            n (int): Lines to print
            c (bool): Clears history if True
        '''
        if c:
            open(PYTHON_HISTORY_PATH, 'w').close()
            print('History cleared ;)')
            return

        if not os.path.exists(PYTHON_HISTORY_PATH):
            return

        # Tail history if on linux.
        if IS_LINUX:
            try:
                os.system('tail -%i %s' % (n, PYTHON_HISTORY_PATH))
            except IOError:
                pass

        print(bright_blue('\nCurrent session [%s]:' % my_timestamp()))
        print(_history())


    def _append_history_file():
        '''Write command history to PYTHON_HISTORY_PATH.'''
        history = _history(include_current=True)
        if not history:
            return
        with open(PYTHON_HISTORY_PATH, 'a+') as fil:
            fil.write("\n'''New session [%s]'''\n" % my_timestamp())
            # Ignore ASCII otherwise Python 3 will throw UnicodeDecodeError in the next session.
            fil.write(history.encode('ascii', errors='ignore') + b'\n')


    # Register _append_history_file() on CLI exit.
    atexit.register(_append_history_file)


    # Make h print history without having to call function. h() works too.
    class History:
        def __call__(self):
            history()

        def __repr__(self):
            history()
            return ''

    h = History()


# My custom Python prompt.
_PROMPT_NAME = ''
class MyPrompt:
    '''My custom Python prompt with timestamp ('01:23:00 PM >>>').

    Can also specify a name with _PROMPT_NAME to help distinguish between multiple sessions.
    01:23:00 PM >>>_PROMPT_NAME = 'prod'
    01:23:01 PM [prod] >>>
    '''
    def __repr__(self):
        if '_PROMPT_NAME' in globals():
            global _PROMPT_NAME
        else:
            _PROMPT_NAME = ''

        now = datetime.datetime.now()
        return '{} {}>>> '.format(
            str(now.strftime('%I:%M:%S %p')),
            '[{}] '.format(_PROMPT_NAME) if _PROMPT_NAME else '')
sys.ps1 = MyPrompt()


# Shortcuts cause I'm lazy and forgetful.
ls = print_path


# Remove unneeded modules.
del atexit, rlcompleter


print('Loading .pythonrc took %s' % human_time(time.time() - start))
