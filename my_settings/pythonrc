#!/usr/bin/env python
# ~/.pythonrc

import math
import os
from pprint import pprint
import re
import subprocess
import sys
import time
from types import ModuleType

from tabulate import tabulate

from lancore import *


IGNORED_ATTRIBUTES = ["__builtins__", "__globals__", "func_globals"]
PYTHON_HISTORY_PATH = os.path.join(os.environ['HOME'], '.python_history')


# Make CLI beautiful with color-printing to terminal using colorama.
try:
    import colorama
except ImportError:
    print 'Module colorama not available.'
    colorama = None
finally:
    # Adds color codes to global variables
    type_to_code = {
        'Fore': ['BLUE', 'CYAN', 'GREEN', 'MAGENTA', 'RED', 'LIGHTGREEN_EX', 'YELLOW', 'RESET',
                 'LIGHTRED_EX'],
        'Style': ['BRIGHT', 'NORMAL', 'DIM', 'RESET_ALL']
    }
    for typ, codes in type_to_code.iteritems():
        for code in codes:
            globals()[code] = getattr(getattr(colorama, typ), code) if colorama else ''

    # Shortcut color global variables.
    globals()['BRIGHT_BLUE'] = lambda s: BRIGHT + BLUE + str(s) + RESET_ALL
    globals()['INFO'] = lambda s: BRIGHT + BLUE + 'INFO:' + RESET_ALL + ' ' + str(s)
    globals()['WARN'] = lambda s: BRIGHT + YELLOW + 'WARNING:' + RESET_ALL + ' ' + str(s)
    globals()['ERROR'] = lambda s: BRIGHT + LIGHTRED_EX + 'ERROR:' + RESET_ALL + ' ' + str(s)
    globals()['CRITICAL'] = lambda s: BRIGHT + colorama.Back.RED + 'CRITICAL:' + RESET_ALL + ' ' + \
        str(s)


def _brighten_it_up(func):
    """Brighten up the output"""
    def wrapper(*args, **kwargs):
        sys.stdout.write(BRIGHT)
        res = func(*args, **kwargs)
        sys.stdout.write(RESET_ALL)
        return res
    return wrapper


def human_int(int_):
    '''Add commas to int every 3 digits (ie. 1,234,567,890)'''
    return '{:,}'.format(int_)


def _num_lines(str_):
    '''Number of lines in string'''
    return str_.count('\n') + 1


def wai(*things, **kwargs):
    for thing in things:
        _wai(thing, **kwargs)


def _wai_text(str_, typ):
    '''What is this text? Can be unicode or str.'''
    if str_:
        if os.path.exists(str_):
            if os.path.isfile(str_):
                if str_.endswith(".ma"):
                    print "Maya ascii file"
                elif str_.endswith(".mb"):
                    print "Maya binary file"
                elif str_.endswith(".exr"):
                    print "EXR image"
                else:
                    print "file path"
            else:
                print "directory"
        elif re.match(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", str_):
            print "IP Address"
        elif re.match(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$', str_):
            print "MAC Address"
        else:
            print "Just a %s:" % typ.__name__, str_
    else:
        print "Empty %s: ''" % typ.__name__


def _wai_number(num, typ):
    '''What is this number? Can be int or float.'''
    if num >= 946702800:  # Epoch date
        print "Epoch time"
        print time.strftime("%Z - %a %Y-%m-%d, %I:%M:%S %p", time.localtime(num))
    elif typ == int:
        if num >= 16:
            # Check if it's a power of 2
            log = math.log(num, 2)
            if log.is_integer():
                print "%i = 2^%i" % (num, int(log))
                return
        print "Just an int:", human_int(num)
    elif typ == float:
        print "Just a float:", num


def _wai_list(list_, typ):
    '''What is this list/tuple?'''
    if list_:
        print BLUE + "%s of %s %s%s" % (
            typ.__name__.title(),
            human_int(len(list_)),
            get_types(list_),
            "s" if len(list_) > 1 else ""
        )
        print NORMAL + GREEN + "[0]: ",
        pprint(list_[0]), BRIGHT
        _print_parent_types(type(list_[0]))
    else:
        print DIM + "Empty %s: %s" % (typ.__name__, str(list_)) + RESET_ALL


def _wai_dict(dict_, typ):
    '''What is this dict?'''
    if dict_:
        print BLUE + "Just a dict of %i {%s: %s}" % (
                len(dict_), get_types(dict_.keys()), get_types(dict_.values()))
        print "Keys: " + GREEN + str(dict_.keys())
    else:
        print DIM + "Empty dict: {}" + RESET_ALL
    return


@_brighten_it_up
def _wai(thing, ignore_private=False, ignore_attrs=[], call=False, skip_callable=False,
         skip_module=True, skip_known=False):
    """What Am I? Prints type and attributes of object thing.

    :param thing object: Anything and everything. That's what we're here to find out. :)
    :param ignore_private bool: Ignores attributes starting with underscore.
    :param ignore_attrs list: List of attributes to ignore.
    :param call bool: Calls attributes that are functions and thing itself if it is callable.
    :param skip_callable bool: Doesn't print callable attributes.
    :param skip_module bool: Skips module attributes.
    :param skip_known bool: If True, prints every attribute even if we know what it is.
    """
    typ = type(thing)

    if not skip_known:
        # Let's see if we know what it is first.
        if thing is None:
            print "It's just None!"
            return
        elif typ in (str, unicode):
            return _wai_text(thing, typ)
        elif typ in (int, float):
            return _wai_number(thing, typ)
        elif typ == dict:
            return _wai_dict(thing, typ)

        from collections import defaultdict
        if typ == defaultdict:
            print BLUE + "defaultdict with %i key(s): %s" % (len(thing), thing.keys())
            return
        elif typ in (list, tuple):
            return _wai_list(thing, typ)

    if callable(thing):
        print _func_name_args_kwargs(thing)
        if thing.__doc__:
            print thing.__doc__

    # So we don't know what it is. Let's print everything we can find about it.
    thing_name = getattr(thing, "__name__", "")
    call_count = private_count = total = 0
    ignore_attrs += IGNORED_ATTRIBUTES
    for attr in dir(thing):
        if attr in ignore_attrs:
            continue
        if attr.startswith("_"):
            private_count += 1
            if ignore_private:
                continue
        total += 1
        try:
            res = getattr(thing, attr)
        except Exception, e:
            print RED + str(e)
            continue

        # Skip if module
        if isinstance(res, ModuleType) and skip_module:
            continue

        # Skip if callable
        is_callable = callable(res)
        long_name = "%s.%s" % (thing_name, attr)
        if is_callable and skip_callable:
            continue
        elif is_callable:
            # Print *args, **kwargs
            print _func_name_args_kwargs(res),
            call_count += 1
            if call:
                _call(res)
            else:
                print getattr(res, "__doc__")
        else:
            print BLUE + "%s:" % long_name + GREEN,
            _print(res)
    if call and callable(thing):
        _call(thing)
    sys.stdout.write(CYAN)
    if not skip_callable:
        print "Callable: %i," % call_count,
    print "Uncallable: %i" % (total - call_count)
    print "Private: %i, Public: %i" % (private_count, total - private_count)
    print "Total: %i" % total

    _print_parent_types(typ)


def _func_name_args_kwargs(func):
    varnames_str = ""
    code = getattr(func, "__code__", None)
    if code:
        co_argcount = getattr(code, "co_argcount", None)
        co_varnames = getattr(code, "co_varnames", None)
        if co_argcount and co_varnames:
            try:
                varnames = list(co_varnames)[0:co_argcount]
            except TypeError:
                print "Could not get func args for", co_varnames
                return varnames_str
            defaults = getattr(func, "__defaults__", [])
            if defaults:
                for i, default in enumerate(defaults):
                    index = len(varnames) - len(defaults) + i
                    varnames[index] = MAGENTA + varnames[index] + BLUE + "=" + YELLOW + \
                        str(default) + BLUE
            varnames_str = ", ".join(varnames)
    return BLUE + "%s(%s):" % (func.__name__, varnames_str) + GREEN


def _print_parent_types(typ):
    """Print types of all parent classes"""
    import inspect
    print typ
    print CYAN + "Parents:" + GREEN, " -> ".join([t.__name__ for t in inspect.getmro(typ)[1:]])
    print CYAN + "Type:" + GREEN, typ.__name__, RESET


def get_types(items):
    '''String of unique types in items.

    >>> get_types(['a', 'b', 'c'])
    'str'
    >>> get_types(['apple', 'banana', u'peach', 2])
    'int, unicode, str'
    '''
    found_types = set()
    for item in items:
        found_types.add(type(item))
    return ', '.join([typ.__name__ for typ in found_types])


def _call(func):
    try:
        res = func()
        _print(res)
    except Exception, e:
        print RED, e


def _print(to_print):
    if isinstance(to_print, basestring):
        print to_print
    else:
        pprint(to_print)


def ns(msg=""):
    """Sends a desktop notification using alias ns"""
    subprocess.call("ns '%s'" % msg, shell=True)


def cb(content):
    """Copies content to clipboard"""
    import clipboard, pyperclip
    try:
        clipboard.copy(content)
    except pyperclip.PyperclipException:
        clipboard.copy(str(content))


def start_QApplication():
    from PyQt4 import QtGui
    return QtGui.QApplication(sys.argv)


def my_date_time_stamp():
    '''Date time stamp the way I like it.'''
    return datetime.datetime.now().strftime('%c')


def _history(include_current=False):
    """Returns interactive python command history"""
    msg = []
    history_len = readline.get_current_history_length()
    end = (history_len + 1) if include_current else history_len
    for i in range(1, end):
        msg.append(readline.get_history_item(i))
    return "\n".join(msg)


def history(n=50, c=False):
    """Python version of bash history command

    Args:
        n (int): Lines to print
        c (bool): Clears history if True
    """
    if c:
        open(PYTHON_HISTORY_PATH, "w").close()
        return

    if not os.path.exists(PYTHON_HISTORY_PATH):
        return
    try:
        os.system("tail -%i %s" % (n, PYTHON_HISTORY_PATH))
    except IOError:
        pass
    print BRIGHT_BLUE("\nCurrent session [%s]:" % my_date_time_stamp())
    print _history()


def _append_history_file():
    history = _history(include_current=True)
    if not history:
        return
    with open(PYTHON_HISTORY_PATH, "a+") as fil:
        fil.write(
            BRIGHT_BLUE("\n'''New session [%s]'''\n" % my_date_time_stamp()))
        fil.write(history + "\n")


# Make h print history without having to call function.
class History:
    def __repr__(self):
        history()
        return ''

h = History()


def hs(str_, max_count=5):
    '''Search interactive python history using grep. Returns last max_count results.

    Args:
        str_ (str): String to search for.
        max_count (int): Max number of lines to show.
    '''
    os.system('grep "%s" %s | tail -%i | grep --color=auto "%s"' % (
        str_, PYTHON_HISTORY_PATH, max_count, str_))


def _is_text(s):
    return type(s) in [str, unicode]


def find(haystack, needle):
    """Recursively finds path to needle in haystack (can be list or dict).

    Args:
        haystack (dict or list): A dict or list.
        needle (anything): Target to find.
    """
    attrs = _find(haystack, needle)
    if not attrs:
        print "Not found"
        return
    path = ""
    for attr in attrs:
        if _is_text(attr):
            path += "['%s']" % attr
        else:
            path += "[%s]" % attr
    print "%s:" % path,
    print eval("haystack%s" % path)


def _find(haystack, needle, path=[]):
    """Recursive helper for find()"""
    if isinstance(haystack, dict):
        for key, val in haystack.iteritems():
            if type(val) in (dict, list):
                res = _find(val, needle, path=path + [key])
                if res:
                    return res
            elif val:
                if _is_text(val) and _is_text(needle) and needle.lower() in val.lower():
                    return path + [key]
                elif type(val) == int and needle == val:
                    return path + [key]
    elif isinstance(haystack, list):
        for index, item in enumerate(haystack):
            if type(item) in (dict, list):
                res = _find(item, needle, path=path + [index])
                if res:
                    return res
            elif item:
                if _is_text(item) and _is_text(needle) and needle.lower() in item.lower():
                    return path + [index]
                elif type(item) == int and needle == item:
                    return path + [index]


def demo_colorama():
    """Print every style and color possible with colorama"""
    for color in dir(colorama.Fore):
        if color.isupper() and color != "RESET":
            print getattr(colorama.Fore, color),
            for style in dir(colorama.Style):
                if style.isupper() and style != "RESET_ALL":
                    print getattr(colorama.Style, style), '"%s %s"' % (style, color),
            print
    sys.stdout.write(RESET_ALL)


def reload_pythonrc():
    '''Reload this file to update current CLI session without exiting. Reloadception!'''
    execfile(os.environ.get('PYTHONSTARTUP'))


'''
Aliases for easier access. How lazy am I?
'''
def print_tabulate(dicts):
    print tabulate(dicts, headers='keys')


# Enable syntax completion and append history file on exit
try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import atexit
    import rlcompleter
    readline.parse_and_bind("tab: complete")
    atexit.register(_append_history_file)
    del atexit, rlcompleter


# My custom Python prompt.
class MyPrompt:
    def __repr__(self):
        now = datetime.datetime.now()
        return '%s%s%s >>> ' % (MAGENTA, str(now.strftime('%I:%M:%S %p')), RESET)

sys.ps1 = MyPrompt()
