#!/usr/bin/env python
# ~/.pythonrc

import math
import os
from pprint import pprint, pformat
import re
import subprocess
import sys
import time
from types import ModuleType

from tabulate import tabulate

from lancore import *
from cli_tools import find, get


IGNORED_ATTRIBUTES = ["__builtins__", "__globals__", "func_globals"]
MAX_LINES = 50
PYTHON_HISTORY_PATH = os.path.join(os.environ['HOME'], '.python_history')
TYPE_TO_REGEX = {
    'E-mail': r'^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,5})$',
    'Whole number': r'^\d+$',
    'Negative int': r'^-\d+$',
    'Negative float': r'^-\d+$',
    'Decimal number (float)': r'^\d*\.\d+$',
    'IP Address': r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',
    'MAC Address': r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$',
    'UUID': r'[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}',
}
FILE_TYPE_TO_EXTENSION = {
    'EXR image': 'exr',
    'Katana file': 'katana',
    'Log file': 'log',
    'Markdown file': 'md',
    'Maya ascii file': 'ma',
    'Maya binary file': 'mb',
    'Nuke script': 'nk',
    'JSON file': 'json',
    'Python file': 'py',
}


def _brighten_it_up(func):
    """Brighten up the output"""
    def wrapper(*args, **kwargs):
        sys.stdout.write(BRIGHT)
        res = func(*args, **kwargs)
        sys.stdout.write(RESET_ALL)
        return res
    return wrapper


def _num_lines(str_):
    '''Number of lines in string'''
    return str_.count('\n') + 1


def wai(*things, **kwargs):
    for thing in things:
        _wai(thing, **kwargs)


def _wai_text(str_, typ):
    '''What is this text? Can be unicode or str.'''
    if str_:
        if os.path.exists(str_):
            # It's a file path.
            if os.path.isfile(str_):
                for file_type, extension in FILE_TYPE_TO_EXTENSION.iteritems():
                    if str_.endswith(extension):
                        print file_type
                        break
                else:
                    print 'file path'
            else:
                print 'directory'
        else:
            # Match by regex of what we know.
            for type_, regex in TYPE_TO_REGEX.iteritems():
                if re.match(regex, str_):
                    print type_
                    break
            else:
                print 'Just a %s:' % typ.__name__, str_
    else:
        print "Empty %s: ''" % typ.__name__


def _wai_number(num, typ):
    '''What is this number? Can be int or float.'''
    if num >= 946702800:  # Epoch date
        print "Epoch time"
        print time.strftime("%Z - %a %Y-%m-%d, %I:%M:%S %p", time.localtime(num))
    elif typ == int:
        if num >= 16:
            # Check if it's a power of 2
            log = math.log(num, 2)
            if log.is_integer():
                print "%i = 2^%i" % (num, int(log))
                return
        print "Just an int:", human_int(num)
    elif typ == float:
        print "Just a float:", num


def _wai_list(list_, typ):
    '''What is this list/tuple?'''
    if list_:
        print BLUE + '%s of %s %s%s' % (
            typ.__name__.title(),
            human_int(len(list_)),
            get_types(list_),
            's' if len(list_) > 1 else ''
        )
        print NORMAL + GREEN + '%s[0]: ' % var_name(list_),
        wai(list_[0]), BRIGHT
        _print_parent_types(type(list_[0]))
    else:
        print DIM + 'Empty %s: %s' % (typ.__name__, str(list_)) + RESET_ALL


def _wai_dict(dict_):
    '''What is this dict?'''
    if dict_:
        keys = dict_.keys()
        print BLUE + 'Just a dict of %i {%s: %s}' % (
            len(dict_), get_types(keys), get_types(dict_.values()))

        keys_print = pformat(sorted(keys)).split('\n')
        print 'Keys: ' + colorama.Style.RESET_ALL + GREEN + '\n'.join(keys_print[:50])
        if len(keys_print) > MAX_LINES:
            print '...'

        # Print dict with least number of depth that's less than MAX_LINES.
        depth = 1
        previous_output = ''
        while True:
            output = pformat(dict_, depth=depth)
            if output.count('\n') > MAX_LINES:
                break

            # Check if everything expanded.
            if output == previous_output:
                break
            previous_output = output
            depth += 1
        if previous_output and depth > 2:
            print BRIGHT_BLUE('Dict:') + GREEN
            print previous_output
    else:
        print DIM + 'Empty dict: {}' + RESET_ALL


@_brighten_it_up
def _wai(thing, ignore_private=False, ignore_attrs=[], call=False, skip_callable=False,
         skip_module=True, skip_known=False):
    """What Am I? Prints type and attributes of object thing.

    :param thing object: Anything and everything. That's what we're here to find out. :)
    :param ignore_private bool: Ignores attributes starting with underscore.
    :param ignore_attrs list: Attributes to ignore.
    :param call bool: Calls attributes that are functions and thing itself if it is callable.
    :param skip_callable bool: Doesn't print callable attributes.
    :param skip_module bool: Skips module attributes.
    :param skip_known bool: If True, prints every attribute even if we know what it is.
    """
    typ = type(thing)

    if not skip_known:
        # Let's see if we know what it is first.
        if thing is None:
            print "It's just None!"
            return
        elif typ in (str, unicode):
            return _wai_text(thing, typ)
        elif typ in (int, float):
            return _wai_number(thing, typ)
        elif typ == dict:
            return _wai_dict(thing)

        from collections import defaultdict, Counter, OrderedDict
        if typ in (defaultdict, Counter, OrderedDict):
            print BLUE + "%s with %i key%s: %s" % (
                typ.__name__.title(), len(thing), 's' if len(thing) > 1 else '', thing.keys())
            return
        elif typ in (list, tuple):
            return _wai_list(thing, typ)

    if callable(thing):
        print _func_name_args_kwargs(thing)
        if thing.__doc__:
            print thing.__doc__

    # So we don't know what it is. Let's print everything we can find about it.
    thing_name = getattr(thing, "__name__", "")
    call_count = private_count = total = 0
    ignore_attrs += IGNORED_ATTRIBUTES
    for attr in dir(thing):
        if attr in ignore_attrs:
            continue
        if attr.startswith("_"):
            private_count += 1
            if ignore_private:
                continue
        total += 1
        try:
            res = getattr(thing, attr)
        except Exception, e:
            print RED + str(e)
            continue

        # Skip if module
        if isinstance(res, ModuleType) and skip_module:
            continue

        # Skip if callable
        is_callable = callable(res)
        long_name = "%s.%s" % (thing_name, attr)
        if is_callable and skip_callable:
            continue
        elif is_callable:
            # Print *args, **kwargs
            print _func_name_args_kwargs(res),
            call_count += 1
            if call:
                _call(res)
            else:
                print getattr(res, "__doc__")
        else:
            print BLUE + "%s:" % long_name + GREEN,
            _print(res)
    if call and callable(thing):
        _call(thing)
    sys.stdout.write(CYAN)
    if not skip_callable:
        print "Callable: %i," % call_count,
    print "Uncallable: %i" % (total - call_count)
    print "Private: %i, Public: %i" % (private_count, total - private_count)
    print "Total: %i" % total

    _print_parent_types(typ)


def _func_name_args_kwargs(func):
    varnames_str = ""
    code = getattr(func, "__code__", None)
    if code:
        co_argcount = getattr(code, "co_argcount", None)
        co_varnames = getattr(code, "co_varnames", None)
        if co_argcount and co_varnames:
            try:
                varnames = list(co_varnames)[0:co_argcount]
            except TypeError:
                print "Could not get func args for", co_varnames
                return varnames_str
            defaults = getattr(func, "__defaults__", [])
            if defaults:
                for i, default in enumerate(defaults):
                    index = len(varnames) - len(defaults) + i
                    varnames[index] = MAGENTA + varnames[index] + BLUE + "=" + YELLOW + \
                        str(default) + BLUE
            varnames_str = ", ".join(varnames)
    func_name = func.__name__ if hasattr(func, '__name__') else str(func)
    return BLUE + "%s(%s):" % (func_name, varnames_str) + GREEN


def _print_parent_types(typ):
    """Print types of all parent classes"""
    import inspect
    print typ
    print CYAN + "Parents:" + GREEN, " -> ".join([t.__name__ for t in inspect.getmro(typ)[1:]])
    print CYAN + "Type:" + GREEN, typ.__name__, RESET


def get_types(items):
    '''String of unique types in items.

    >>> get_types(['a', 'b', 'c'])
    'str'
    >>> get_types(['apple', 'banana', u'peach', 2])
    'int, unicode, str'
    '''
    found_types = set()
    for item in items:
        found_types.add(type(item))
    return ', '.join([typ.__name__ for typ in found_types])


def _call(func):
    try:
        res = func()
        _print(res)
    except Exception, e:
        print RED, e


def _print(to_print):
    if isinstance(to_print, basestring):
        print to_print
    else:
        pprint(to_print)


def ns(msg=""):
    """Sends a desktop notification using alias ns"""
    subprocess.call("ns '%s'" % msg, shell=True)


def cb(content):
    """Copies content to clipboard"""
    import clipboard, pyperclip
    try:
        clipboard.copy(content)
    except pyperclip.PyperclipException:
        clipboard.copy(str(content))


def start_qt_application():
    from PyQt4 import QtGui
    return QtGui.QApplication(sys.argv)


def my_date_time_stamp():
    '''Date time stamp the way I like it.'''
    return datetime.datetime.now().strftime('%c')


def _history(include_current=False):
    """Returns current interactive python session command history"""
    msg = []
    history_len = readline.get_current_history_length()
    end = (history_len + 1) if include_current else history_len
    for i in range(1, end):
        msg.append(readline.get_history_item(i))
    return "\n".join(msg)


# Make current_history print current history without having to call function.
# current_history() works too.
class CurrentHistory:
    def __call__(self):
        print _history()

    def __repr__(self):
        print _history()
        return ''

current_history = CurrentHistory()


def history(n=50, c=False):
    """Python version of bash history command

    Args:
        n (int): Lines to print
        c (bool): Clears history if True
    """
    if c:
        open(PYTHON_HISTORY_PATH, "w").close()
        return

    if not os.path.exists(PYTHON_HISTORY_PATH):
        return
    try:
        os.system("tail -%i %s" % (n, PYTHON_HISTORY_PATH))
    except IOError:
        pass
    print BRIGHT_BLUE("\nCurrent session [%s]:" % my_date_time_stamp())
    print _history()


def _append_history_file():
    history = _history(include_current=True)
    if not history:
        return
    with open(PYTHON_HISTORY_PATH, "a+") as fil:
        fil.write(
            BRIGHT_BLUE("\n'''New session [%s]'''\n" % my_date_time_stamp()))
        fil.write(history + "\n")


# Make h print history without having to call function. h() works too.
class History:
    def __call__(self):
        history()

    def __repr__(self):
        history()
        return ''

h = History()

less_history = lambda: os.system('less -r +G %s' % PYTHON_HISTORY_PATH)


def hs(str_, max_count=5):
    '''Regex search interactive python history using grep. Returns last max_count results.

    Args:
        str_ (str): String to search for.
        max_count (int): Max number of lines to show.
    '''
    os.system('grep "%s" %s | tail -%i | grep --color=auto "%s"' % (
        str_, PYTHON_HISTORY_PATH, max_count, str_))


def demo_colorama(case='upper'):
    '''Print every style and color possible with colorama.

    Args:
        case (str): One of 'upper', 'title', or 'lower'.
    '''
    for color in dir(colorama.Fore):
        if color.isupper() and color != 'RESET':
            print getattr(colorama.Fore, color),
            for style in dir(colorama.Style):
                if style.isupper() and style != 'RESET_ALL':
                    text = '"%s %s"' % (style, color)
                    if case == 'title':
                        text = text.title()
                    elif case == 'lower':
                        text = text.lower()
                    print getattr(colorama.Style, style), text,
            print
    sys.stdout.write(RESET_ALL)


def reload_pythonrc():
    '''Reload this file to update current CLI session without exiting. Reloadception!'''
    execfile(os.environ.get('PYTHONSTARTUP'))


def print_tabulate(
        input_, keys=None, sorted_key=None, reverse=False, limit=MAX_LINES, headers='keys'):
    '''Wrapper around tabulate() to print table from dict(s) with keys as headers.

    Args:
        input_ ([dict] or dict): Dict(s) to print.
        keys (list): Print only these keys as columns in this order. Print all keys if None.
            Supports dot notation '.' for nested dicts.
        sorted_key (list of keys or whatever keys are): Key to sort rows by.
        reverse (bool): Reverse row sort order if True. Passed to sorted().
        limit (int): Limit number of results. Show all if negative.
        headers (str): Passed to tabulate(). Show keys as headers by difficult.
    '''
    if isinstance(input_, dict):
        from collections import OrderedDict
        new_dicts = []
        for key, val in input_.iteritems():
            new_dict = OrderedDict()
            new_dict['key'] = key
            if isinstance(val, dict):
                for key_1, val_1 in val.iteritems():
                    new_dict[key_1] = val_1
            new_dicts.append(new_dict)
        dicts = new_dicts
    else:
        dicts = input_

    # Sort by specified key(s.
    if sorted_key:
        if isinstance(sorted_key, list):
            # List of keys to sort by.
            sorted_key_func = lambda x: tuple(x.get(key) for key in sorted_key)
        else:
            sorted_key_func = lambda x: x.get(sorted_key)
        dicts = sorted(dicts, key=sorted_key_func, reverse=reverse)

    # Filter to only specified keys in order.
    if keys:
        from collections import OrderedDict
        new_dicts = []
        for dict_ in dicts:
            new_dict = OrderedDict()
            for key in keys:
                if isinstance(key, str) and '.' in key:
                    # Handle dot notation for getting attributes within sub dicts.
                    new_dict[key] = get(dict_, *key.split('.'))
                else:
                    new_dict[key] = dict_.get(key)
            new_dicts.append(new_dict)
    else:
        new_dicts = dicts

    # Limit rows to show.
    is_limited = False
    if len(new_dicts) > limit >= 0:
        is_limited = True
        new_dicts = new_dicts[:limit]

    # Print table.
    print tabulate(new_dicts, headers)

    # Print results are limited.
    if is_limited:
        print '...'
        print 'Only showing %i results' % limit


# Enable syntax completion and append history file on exit
try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import atexit
    import rlcompleter
    readline.parse_and_bind("tab: complete")
    atexit.register(_append_history_file)
    del atexit, rlcompleter


# My custom Python prompt.
class MyPrompt:
    def __repr__(self):
        now = datetime.datetime.now()
        return '%s >>> ' % str(now.strftime('%I:%M:%S %p'))

sys.ps1 = MyPrompt()
