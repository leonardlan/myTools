#!/usr/bin/env python
# ~/.pythonrc

import subprocess

# Enable syntax completion
try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import rlcompleter
    readline.parse_and_bind("tab: complete")

from pprint import pprint

# Import colorama for color-printing to terminal
try:
    import colorama
except ImportError:
    print "Module colorama not available."
    colorama = None
finally:
    BLUE = colorama.Fore.BLUE if colorama else ""
    BRIGHT = colorama.Style.BRIGHT if colorama else ""
    CYAN = colorama.Fore.CYAN if colorama else ""
    GREEN = colorama.Fore.GREEN if colorama else ""
    RED = colorama.Fore.RED if colorama else ""
    RESET_ALL = colorama.Style.RESET_ALL if colorama else ""


def debug(thing, ignore_private=False, ignore_attrs=[], call=False, skip_callable=False):
    """Prints type and attributes of object thing.

    :param thing object: An object to debug.
    :param ignore_private bool: Ignores attributes starting with underscore.
    :param ignore_attrs list: List of attributes to ignore.
    :param call bool: Calls attributes that are functions and thing itself if it is callable.
    """
    thing_name = getattr(thing, "__name__") if hasattr(thing, "__name__") else ""
    print BRIGHT
    call_count = private_count = total = 0
    for attr in dir(thing):
        if attr in ignore_attrs:
            continue
        if attr.startswith("_"):
            private_count += 1
            if ignore_private:
                continue
        total += 1
        try:
            res = getattr(thing, attr)
        except Exception, e:
            print RED, e
            continue
        long_name = "%s.%s" % (thing_name, attr)
        is_callable = callable(res)
        if is_callable and skip_callable:
            continue
        elif is_callable:
            print BLUE + "%s(): " % long_name + GREEN,
            call_count += 1
            if call:
                _call(res)
            else:
                print getattr(res, "__doc__")
        else:
            print BLUE + "%s: " % long_name + GREEN,
            _print(res)
    if call and callable(thing):
        _call(thing)
    print "%sCallable: %i, Uncallable: %i" % (CYAN, call_count, total - call_count)
    print "Private: %i, Public: %i" % (private_count, total - private_count)
    print "Total: %i" % total
    print BLUE + "type:" + GREEN, type(thing), RESET_ALL


def _call(func):
    try:
        res = func()
        _print(res)
    except Exception, e:
        print RED, e


def _print(to_print):
    if isinstance(to_print, basestring):
        print to_print
    else:
        pprint(to_print)


def ns(msg=""):
    """ Sends a desktop notification using alias ns """
    subprocess.call(["/bin/bash", "-i", "-c", "ns %s" % msg])


def cb(content):
    """ Copies content to clipboard """
    import clipboard, pyperclip
    try:
        clipboard.copy(content)
    except pyperclip.PyperclipException:
        clipboard.copy(str(content))


def start_QApplication():
    import sys
    from bron_qt.qt import QtGui

    return QtGui.QApplication(sys.argv)


def history():
    """ Prints interactive python command history """
    for i in range(readline.get_current_history_length() - 1):
        print readline.get_history_item(i + 1)
