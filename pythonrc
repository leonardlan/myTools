#!/usr/bin/env python
# ~/.pythonrc

import os
import re
import subprocess
import sys
import time


# Enable syntax completion
try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import rlcompleter
    readline.parse_and_bind("tab: complete")

from pprint import pprint

# Import colorama for color-printing to terminal
try:
    import colorama
except ImportError:
    print "Module colorama not available."
    colorama = None
finally:
    # Adds color codes to global variables
    type_to_code = {"Fore": ["BLUE", "CYAN", "GREEN", "RED"], "Style": ["BRIGHT", "RESET_ALL"]}
    for typ, codes in type_to_code.iteritems():
        for code in codes:
            globals()[code] = getattr(getattr(colorama, typ), code) if colorama else ""


def _brighten_it_up(func):
    """Brighten up the output"""
    def wrapper(*args, **kwargs):
        sys.stdout.write(BRIGHT)
        res = func(*args, **kwargs)
        sys.stdout.write(RESET_ALL)
        return res
    return wrapper


@_brighten_it_up
def wai(thing, ignore_private=False, ignore_attrs=[], call=False, skip_callable=False):
    """What Am I? Prints type and attributes of object thing.

    :param thing object: Anything and everything. That's what we're here to find out.
    :param ignore_private bool: Ignores attributes starting with underscore.
    :param ignore_attrs list: List of attributes to ignore.
    :param call bool: Calls attributes that are functions and thing itself if it is callable.
    :param skip_callable bool: Doesn't print callable attributes.
    """
    typ = type(thing)

    # Let's see if we know what it is first.
    if typ in (str, unicode):
        if thing:
            print "Just a %s:" % typ.__name__, thing
            if os.path.exists(thing):
                if os.path.isfile(thing):
                    print "file path"
                else:
                    print "directory"
            elif re.match(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", thing):
                print "IP Address"
            elif re.match(r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$', thing):
                print "MAC Address"
        else:
            print "Empty %s: ''" % typ.__name__
        return
    elif typ in (int, float):
        print "Just an int:", thing
        if thing >= 946702800:  # Is it epoch time?
            print time.strftime("%Z - %Y/%m/%d, %H:%M:%S", time.localtime(thing))
        return
    elif typ == dict:
        if thing:
            print "Just a dict:"
            pprint(thing)
        else:
            print RED + "Empty dict: {}"
        return
    elif typ in (list, tuple):
        if thing:
            print BLUE + "%s of %i %s" % (typ.__name__.title(), len(thing), type(thing[0]))
            print GREEN + "[0]:", pprint(thing[0])
            _print_types(type(thing[0]))
        else:
            print RED + "Empty %s: %s" % (typ.__name__, str(thing))
        return

    # So we don't know what it is. Let's print everything we can find about it.
    thing_name = getattr(thing, "__name__") if hasattr(thing, "__name__") else ""
    call_count = private_count = total = 0
    for attr in dir(thing):
        if attr in ignore_attrs:
            continue
        if attr.startswith("_"):
            private_count += 1
            if ignore_private:
                continue
        total += 1
        try:
            res = getattr(thing, attr)
        except Exception, e:
            print RED + e
            continue
        long_name = "%s.%s" % (thing_name, attr)
        is_callable = callable(res)
        if is_callable and skip_callable:
            continue
        elif is_callable:
            print BLUE + "%s():" % long_name + GREEN,
            call_count += 1
            if call:
                _call(res)
            else:
                print getattr(res, "__doc__")
        else:
            print BLUE + "%s:" % long_name + GREEN,
            _print(res)
    if call and callable(thing):
        _call(thing)
    sys.stdout.write(CYAN)
    if not skip_callable:
        print "Callable: %i," % call_count,
    print "Uncallable: %i" % (total - call_count)
    print "Private: %i, Public: %i" % (private_count, total - private_count)
    print "Total: %i" % total

    _print_types(typ)


def _print_types(typ):
    import inspect
    print CYAN + "Parents:" + GREEN, inspect.getmro(typ)[1:]  # Print types of all parent classes
    print CYAN + "Type:" + GREEN, typ


def _call(func):
    try:
        res = func()
        _print(res)
    except Exception, e:
        print RED, e


def _print(to_print):
    if isinstance(to_print, basestring):
        print to_print
    else:
        pprint(to_print)


def ns(msg=""):
    """ Sends a desktop notification using alias ns """
    subprocess.call(["/bin/bash", "-i", "-c", "ns %s" % msg])


def cb(content):
    """ Copies content to clipboard """
    import clipboard, pyperclip
    try:
        clipboard.copy(content)
    except pyperclip.PyperclipException:
        clipboard.copy(str(content))


def start_QApplication():
    from bron_qt.qt import QtGui

    return QtGui.QApplication(sys.argv)


def history():
    """ Returns interactive python command history """
    msg = []
    for i in range(1, readline.get_current_history_length()):
        msg.append(readline.get_history_item(i))
    return "\n".join(msg)


def print_history():
    print history()
