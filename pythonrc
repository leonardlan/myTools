#!/usr/bin/env python
# ~/.pythonrc

import subprocess
import sys

# Enable syntax completion
try:
    import readline
except ImportError:
    print "Module readline not available."
else:
    import rlcompleter
    readline.parse_and_bind("tab: complete")

from pprint import pprint

# Import colorama for color-printing to terminal
try:
    import colorama
except ImportError:
    print "Module colorama not available."
    colorama = None
finally:
    for color in ["BLUE", "CYAN", "GREEN", "RED"]:
        globals()[color] = getattr(colorama.Fore, color) if colorama else ""
    for style in ["BRIGHT", "RESET_ALL"]:
        globals()[style] = getattr(colorama.Style, style) if colorama else ""


def debug(thing, ignore_private=False, ignore_attrs=[], call=False, skip_callable=False):
    """Prints type and attributes of object thing.

    :param thing object: An object to debug.
    :param ignore_private bool: Ignores attributes starting with underscore.
    :param ignore_attrs list: List of attributes to ignore.
    :param call bool: Calls attributes that are functions and thing itself if it is callable.
    :param skip_callable bool: Doesn't print callable attributes.
    """
    typ = type(thing)
    sys.stdout.write(BRIGHT)

    if typ == list:
        if thing:
            print BLUE + "List of %i %s" % (len(thing), type(thing[0]))
            print GREEN + "[0]:", thing[0]
            _print_types(type(thing[0]))
            print RESET_ALL
        else:
            print RED + "Empty list: []", RESET_ALL
        return

    thing_name = getattr(thing, "__name__") if hasattr(thing, "__name__") else ""
    call_count = private_count = total = 0
    for attr in dir(thing):
        if attr in ignore_attrs:
            continue
        if attr.startswith("_"):
            private_count += 1
            if ignore_private:
                continue
        total += 1
        try:
            res = getattr(thing, attr)
        except Exception, e:
            print RED + e
            continue
        long_name = "%s.%s" % (thing_name, attr)
        is_callable = callable(res)
        if is_callable and skip_callable:
            continue
        elif is_callable:
            print BLUE + "%s():" % long_name + GREEN,
            call_count += 1
            if call:
                _call(res)
            else:
                print getattr(res, "__doc__")
        else:
            print BLUE + "%s:" % long_name + GREEN,
            _print(res)
    if call and callable(thing):
        _call(thing)
    print "%sCallable: %i, Uncallable: %i" % (CYAN, call_count, total - call_count)
    print "Private: %i, Public: %i" % (private_count, total - private_count)
    print "Total: %i" % total

    _print_types(typ)

    print RESET_ALL


def _print_types(typ):
    import inspect
    print BLUE + "parents:" + GREEN, inspect.getmro(typ)  # Print types of all parent classes
    print BLUE + "type:" + GREEN, typ


def _call(func):
    try:
        res = func()
        _print(res)
    except Exception, e:
        print RED, e


def _print(to_print):
    if isinstance(to_print, basestring):
        print to_print
    else:
        pprint(to_print)


def ns(msg=""):
    """ Sends a desktop notification using alias ns """
    subprocess.call(["/bin/bash", "-i", "-c", "ns %s" % msg])


def cb(content):
    """ Copies content to clipboard """
    import clipboard, pyperclip
    try:
        clipboard.copy(content)
    except pyperclip.PyperclipException:
        clipboard.copy(str(content))


def start_QApplication():
    from bron_qt.qt import QtGui

    return QtGui.QApplication(sys.argv)


def history():
    """ Returns interactive python command history """
    msg = []
    for i in range(1, readline.get_current_history_length()):
        msg.append(readline.get_history_item(i))
    return "\n".join(msg)
